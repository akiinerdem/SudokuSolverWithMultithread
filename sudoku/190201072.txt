package sudokuSolver;

import javax.swing.*;
import javax.swing.filechooser.FileSystemView;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class Run {

    public static BufferedWriter bw = null;// to write moves to file
    public static FileWriter fw = null;

    static {
        try {
            fw = new FileWriter("moves.txt");
            bw = new BufferedWriter(fw);
        } catch (Exception ex) {
        }
    }

    public static void main(String[] args) {
        new Run();
    }


    public Run() {
        int[][] sudokuBoard = new int[9][9];
        /**
         * se√ßilen dosyadan sudokuyu okur ve array haline getirir
         */
        try (Stream<String> stream = Files.lines(Paths.get(askForTxt().getAbsolutePath()))) {//Prompts the user to select a file. Reads the selected file line by line.
            int j = 0;
            for (Object satir : stream.toArray()) {
                for (int i = 0; i < satir.toString().length(); i++) {
                    if (satir.toString().charAt(i) == '*') {
                        sudokuBoard[j][i] = 0;
                    } else {
                        sudokuBoard[j][i] = Integer.parseInt("" + satir.toString().charAt(i));
                    }
                }
                j += 1;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("Sudoku To Solve:");
        printSudoku(sudokuBoard);


        SudokuThread thread1 = new SudokuThread(copyBoard(sudokuBoard));
        SudokuThread thread2 = new SudokuThread(copyBoard(sudokuBoard));
        SudokuThread thread3 = new SudokuThread(copyBoard(sudokuBoard));
        SudokuThread thread4 = new SudokuThread(copyBoard(sudokuBoard));
        SudokuThread thread5 = new SudokuThread(copyBoard(sudokuBoard));
        thread1.setName("Solver1");
        thread2.setName("Solver2");
        thread3.setName("Solver3");
        thread4.setName("Solver4");
        thread5.setName("Solver5");
        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
        thread5.start();
        thread1.interrupt();//threads stop when the job is done
        thread2.interrupt();
        thread3.interrupt();
        thread4.interrupt();
        thread5.interrupt();
        /**
         * After the threads are finished, move control is done.
         */
        boolean thread1Over = false;
        boolean thread2Over = false;
        boolean thread3Over = false;
        boolean thread4Over = false;
        boolean thread5Over = false;

        while (!thread1Over) {
            if (!thread1.isAlive()) {
                thread1Over = true;
                thread1.printMoves();
            }
        }
        while (!thread2Over) {
            if (!thread2.isAlive()) {
                thread2Over = true;
                thread2.printMoves();
            }
        }
        while (!thread3Over) {
            if (!thread3.isAlive()) {
                thread3Over = true;
                thread3.printMoves();
            }
        }
        while (!thread4Over) {
            if (!thread4.isAlive()) {
                thread4Over = true;
                thread4.printMoves();
            }
        }
        while (!thread5Over) {
            if (!thread5.isAlive()) {
                thread5Over = true;
                thread5.printMoves();
            }
        }
        try {
            if (Run.bw != null)//closes the file after typing
                Run.bw.close();
            if (Run.fw != null)//
                Run.fw.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    /**
     * opens a file request screen to the user, returns the received file
     */
    private File askForTxt() {
        JFileChooser jfc = new JFileChooser(FileSystemView.getFileSystemView().getHomeDirectory());
        File secilenDosya = null;
        int returnValue = jfc.showOpenDialog(null);

        if (returnValue == JFileChooser.APPROVE_OPTION) {
            secilenDosya = jfc.getSelectedFile();
        }
        return secilenDosya;
    }
    /**
     * We copy the board for each thread and give it to the thread to solve it.
     * If we give all threads the same board, the moment someone changes the bits, the whole solution is broken.
     */
    private int[][] copyBoard(int[][] tahta) {
        int[][] copiedBoard = new int[9][9];

        int i = 0, j = 0;
        for (int[] ints : tahta) {
            for (int deger : ints) {
                copiedBoard[i][j] = deger;
                j++;
            }
            i++;
            j = 0;
        }
        return copiedBoard;
    }

    void printSudoku(int[][] solution) {
        for (int i = 0; i < 9; ++i) {
            if (i % 3 == 0)
                System.out.println(" -----------------------");
            for (int j = 0; j < 9; ++j) {
                if (j % 3 == 0) System.out.print("| ");
                System.out.print(solution[i][j] == 0
                        ? "*"
                        : Integer.toString(solution[i][j]));

                System.out.print(' ');
            }
            System.out.println("|");
        }
        System.out.println(" -----------------------");
    }
}



package sudokuSolver;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;


public class SudokuThread extends Thread {
    public static boolean isItOver = false;
    public long beginning, finish;
    private List<Move> moves;
    private int[][] sudokuBoard;

    public SudokuThread(int[][] sudokuBoard) {
        this.sudokuBoard = sudokuBoard;
        moves = new ArrayList<>();
    }

    /**
     * Running method of Thread
     */
    @Override
    public void run() {//the action after thread started
        beginning = System.currentTimeMillis();
        int i, j;
        if (getName().contains("1")) {//
            i = new Random().nextInt(5);
            j = new Random().nextInt(5);
        } else if (getName().contains("2")) {
            i = new Random().nextInt(5);
            j = new Random().nextInt(5);
        } else {
            i = new Random().nextInt(5);
            j = new Random().nextInt(5);
        }
        if (solve(i, j, sudokuBoard)) {
            printTime();
            printSudoku(sudokuBoard);
        }
    }



    boolean solve(int i, int j, int[][] sudokuToSolve) {
        if (isItOver) {
            if (isAlive()) {
                stop();
                System.out.println("son hali");
                printSudoku(sudokuToSolve);
            }
        }
        else {
            bekle();
        }

        if (i == 9) {
            i = 0;
            if (++j == 9)
                j = 0;
        }

        if (checkFinished(sudokuToSolve)) {
            finish = System.currentTimeMillis();
            return true;
        }

        if (sudokuToSolve[i][j] != 0)
            return solve(i + 1, j, sudokuToSolve);

        for (int val = 1; val <= 9; ++val) {
            if (check(i, j, val, sudokuToSolve)) {
                sudokuToSolve[i][j] = val;
                moves.add(new Move(i, j, val));
                if (solve(i + 1, j, sudokuToSolve))
                    return true;
            }
        }
        sudokuToSolve[i][j] = 0;
        return false;
    }

    /**
     * method that prints the moves after the solution is found
     */
    public void printMoves() {
        System.out.println("#########################################");
        System.out.println("#########################################");
        System.out.println(getName() + " Moves");
        int i = 0;
        for (Move move : moves) {
            if (i % 10 == 0) {
                System.out.println();
            }
            System.out.print(move + "\t");
            i++;
        }
        System.out.println();
        System.out.println("Latest status of sudoku: ");
        printSudoku(sudokuBoard);
        System.out.println("#########################################");
        System.out.println("#########################################");
        printMovesToTxt();
    }


    private void bekle() {
        try {
            int beklemeSuresi = new Random().nextInt(5);
            Thread.sleep(beklemeSuresi);
        } catch (InterruptedException e) {

        }
    }

    /**
     * checks if sudoku is solved
     */
    boolean checkFinished(int[][] sudokuToSolve) {
        for (int[] area : sudokuToSolve) {
            for (int number : area) {
                if (number == 0) {
                    return false;
                }
            }
        }
        isItOver = true;
        return true;
    }

    /**
     * Check here before assigning a value to sudoku
     */
    boolean check(int i, int j, int val, int[][] sudokuToSolve) {
        //checks rows
        for (int k = 0; k < 9; ++k)
            if (val == sudokuToSolve[k][j])
                return false;
        // checks columns
        for (int k = 0; k < 9; ++k)
            if (val == sudokuToSolve[i][k])
                return false;
        /**
         * Controls 3x3 areas
         */
        int rowArea = (i / 3) * 3;
        int columnArea = (j / 3) * 3;
        for (int k = 0; k < 3; ++k)
            for (int m = 0; m < 3; ++m)
                if (val == sudokuToSolve[rowArea + k][columnArea + m])
                    return false;

        return true;
    }

    void printSudoku(int[][] solution) {
        for (int i = 0; i < 9; ++i) {
            if (i % 3 == 0)
                System.out.println(" -----------------------");
            for (int j = 0; j < 9; ++j) {
                if (j % 3 == 0) System.out.print("| ");
                System.out.print(solution[i][j] == 0
                        ? "*"
                        : Integer.toString(solution[i][j]));

                System.out.print(' ');
            }
            System.out.println("|");
        }
        System.out.println(" -----------------------");
    }

    public void printTime() {
        System.out.println("Solved by " + getName() + " in " + (finish - beginning) + " millisecond.");
    }

    private void printMovesToTxt() {

      try {
            Run.bw.write("#########################################\n");
            Run.bw.write("#########################################\n");
            Run.bw.write(getName() + " Moves\n");
            int h = 0;
            for (Move move : moves) {
                if (h % 10 == 0) {
                    Run.bw.newLine();
                }
                Run.bw.write(move + "\t");
                h++;
            }
            Run.bw.newLine();
            Run.bw.write("Latest status of sudoku: \n");
            Run.bw.write("#########################################\n");
            Run.bw.write("#########################################\n");
            for (int i = 0; i < 9; ++i) {
                if (i % 3 == 0)
                    Run.bw.write(" -----------------------\n");
                for (int j = 0; j < 9; ++j) {
                    if (j % 3 == 0) Run.bw.write("| ");
                    Run.bw.write(sudokuBoard[i][j] == 0
                            ? "*"
                            : Integer.toString(sudokuBoard[i][j]));

                    Run.bw.write(' ');
                }
                Run.bw.write("|\n");
            }
            Run.bw.write(" -----------------------\n");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



package sudokuSolver;

public class Move {
    private int row;
    private int column;
    private int value;

    public Move(int row, int column, int value) {
        this.row = row;
        this.column = column;
        this.value = value;
    }

    public int getRow() {
        return row;
    }

    public void setRow(int row) {
        this.row = row;
    }

    public int getColumn() {
        return column;
    }

    public void setColumn(int column) {
        this.column = column;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "["+ row +"]["+ column +"] = "+ value +" ";
    }
}